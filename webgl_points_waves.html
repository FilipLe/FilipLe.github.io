<!DOCTYPE html>
<html lang="en">

<head>
    <title></title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>

<body style="overflow: hidden; margin: 0;">


    <script type="x-shader/x-vertex" id="vertexshader">

        attribute float scale; void main() { vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 ); gl_PointSize = scale * ( 300.0 / - mvPosition.z ); gl_Position = projectionMatrix * mvPosition; }

    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">

        uniform vec3 color; void main() { if ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 ) discard; gl_FragColor = vec4( color, 1.0 ); }

    </script>

    <script type="module">

        import * as THREE from '../build/three.module.js'; import Stats from './jsm/libs/stats.module.js'; var SEPARATION = 100, AMOUNTX = 60, AMOUNTY = 60; var container, stats; var camera, scene, renderer; var particles, count = 0; var mouseX = 0, mouseY =
        0; var windowHalfX = window.innerWidth / 2; var windowHalfY = window.innerHeight / 2; init(); animate(); function init() { container = document.createElement( 'div' ); document.body.appendChild( container ); camera = new THREE.PerspectiveCamera(
        45, window.innerWidth / window.innerHeight, 460, 10000 ); camera.position.z = 1600; camera.position.y = 6600; camera.position.x = 6600; scene = new THREE.Scene(); // var numParticles = AMOUNTX * AMOUNTY; var positions = new Float32Array( numParticles
        * 3 ); var scales = new Float32Array( numParticles ); var i = 0, j = 0; for ( var ix = 0; ix
        < AMOUNTX; ix ++ ) { for ( var iy=0 ; iy < AMOUNTY; iy ++ ) { positions[ i ]=i x * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 ); // x positions[
            i + 1 ]=0 ; // y positions[ i + 2 ]=i y * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 ); // z scales[ j ]=1 ; i +=3 ; j ++; } } var geometry=n ew THREE.BufferGeometry(); geometry.setAttribute( 'position', new THREE.BufferAttribute( positions,
            3 ) ); geometry.setAttribute( 'scale', new THREE.BufferAttribute( scales, 1 ) ); var material=n ew THREE.ShaderMaterial( { uniforms: { color: { value: new THREE.Color( 0x3a3a3a ) }, }, vertexShader: document.getElementById( 'vertexshader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentshader' ).textContent } ); // particles=n ew THREE.Points( geometry, material ); scene.add( particles ); // renderer=n ew THREE.WebGLRenderer( { antialias: true } ); renderer.setPixelRatio( window.devicePixelRatio
            ); renderer.setSize( window.innerWidth, window.innerHeight ); container.appendChild( renderer.domElement ); stats=n ew Stats(); container.appendChild( stats.dom ); document.addEventListener( 'mousemove', onDocumentMouseMove, true ); document.addEventListener(
            'touchstart', onDocumentTouchStart, false ); document.addEventListener( 'touchmove', onDocumentTouchMove, false ); // window.addEventListener( 'resize', onWindowResize, false ); } function onWindowResize() { windowHalfX=w indow.innerWidth / 2; windowHalfY=w
            indow.innerHeight / 2; camera.aspect=w indow.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); } // function onDocumentMouseMove( event ) { mouseX=e vent.clientX - windowHalfX;
            mouseY=e vent.clientY - windowHalfY; } function onDocumentTouchStart( event ) { if ( event.touches.length===1 ) { event.preventDefault(); mouseX=e vent.touches[ 0 ].pageX - windowHalfX; mouseY=e vent.touches[ 0 ].pageY - windowHalfY; } } function
            onDocumentTouchMove( event ) { if ( event.touches.length===1 ) { event.preventDefault(); mouseX=e vent.touches[ 0 ].pageX - windowHalfX; mouseY=e vent.touches[ 0 ].pageY - windowHalfY; } } // function animate() { requestAnimationFrame( animate
            ); render(); stats.update(); } function render() { camera.position.x +=( mouseX - camera.position.x ) * .05; camera.position.y +=( - mouseY - camera.position.y ) * .05; camera.lookAt( scene.position ); var positions=p articles.geometry.attributes.position.array;
            var scales=p articles.geometry.attributes.scale.array; var i=0 , j=0 ; for ( var ix=0 ; ix < AMOUNTX; ix ++ ) { for ( var iy=0 ; iy < AMOUNTY; iy ++ ) { positions[ i + 1 ]=( Math.sin( ( ix + count ) * 0.3 ) * 50 ) + ( Math.sin( ( iy + count )
            * 0.5 ) * 50 ); scales[ j ]=( Math.sin( ( ix + count ) * 0.3 ) + 1 ) * 8 + ( Math.sin( ( iy + count ) * 0.5 ) + 1 ) * 8; i +=3 ; j ++; } } particles.geometry.attributes.position.needsUpdate=t rue; particles.geometry.attributes.scale.needsUpdate=t
            rue; renderer.render( scene, camera ); count +=0 .1; } </script>
</body>

</html>